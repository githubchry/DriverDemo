## 中断

外设产生数据，soc处理数据，异步

soc不知道外设什么时候产生数据，轮询效率不高，有缺陷

通过中断解决：soc处理其他事务，外设产生数据时通过中断主动告知soc，soc暂停处理其他事务，处理完外设产生的数据后继续处理其他事务。

外设很多的时候，触摸屏，按钮，网卡。。。。对soc而言需要管理，中断控制器gic就是用来管理中断的。屏蔽，优先级，记录，区分。外设连接到GIC，GIC通过FIQ和IRQ两根线连接到CPU。

[IRQ和FIQ中断的区别](https://blog.csdn.net/michaelcao1980/article/details/19542039)

以上讨论的是硬件模型中的外部中断。对于CPU而言处理中断比较复杂，初始化，使能，异常向量表。。。。不做讨论。

对于Linux内核而言，对于中断只关注两个东西

1. 中断号
2. 中断的处理方法



## 中断号

获取中断号的方法：

### 过时方法

内核版本2.6：宏定义 IQR_EINT(x)，x是在数据手册中定义的中断号码，需要查datasheet



### 设备树

内核版本3.14：sdk已经在pincrtl.dtis定义好了板子的资源信息，在上面找到按钮连接的引脚aaa，上面描述了中断信息，包括中断号，不需要查datasheet



然后根据上面的资源信息，在dts定义自己的设备节点描述按键：

继承于pincrtl.dtis里面的aaa，并使用了aaa里面第2组中断，触发方式为4

```
key_irq_node{
	compatible = "test_key";
	interrupt-parent = <&aaa>;
	interrupts = <2 4>;	//2表示aaa的第2组中断(从0开始)，4表示触发方式 0248
};
```

编译下载运行。

可以看到`ll /dev/device-tree/key_irq_node`

### 代码

- 获取到设备树中的节点

```c
struct device_node *np = of_find_node_by_path("/key_irq_node");
```

- 通过节点获取中断号码

```c
//第二个参数0表示第0个中断，因为自定义的设备树节点里面只定义了一个中断
int irqno = irq_of_parse_and_map(np, 0);   
```

- 申请中断

```c
/*
参数1： irq 	设备对应的中断号
参数2： handler 	中断的处理函数 
	typedef irqreturn_t (*irq_handler_t)(int, void *);
参数3：flags 	触发方式
	#define IRQF_TRIGGER_NONE	0x00000000  //内部控制器触发中断的时候的标志
	#define IRQF_TRIGGER_RISING	0x00000001 //上升沿
	#define IRQF_TRIGGER_FALLING	0x00000002 //下降沿
	#define IRQF_TRIGGER_HIGH	0x00000004  // 高点平
	#define IRQF_TRIGGER_LOW	0x00000008 //低电平触发
参数4：name 	中断的描述，自定义,主要是给用户查看的
	/proc/interrupts
参数5：dev 	传递给参数2中函数指针的值
返回值： 正确为0，错误非0
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char * name, void * dev)

```

- 处理中断

```
参数2的赋值：即中断处理函数
irqreturn_t key_irq_handler(int irqno, void *devid)
{
	return IRQ_HANDLED;
}
```

- 把中断信息传递到用户空间

```c
ret = copy_to_user(buf, &keyirq_demo_dev->event, sizeof(struct key_event));   
```



## 进程调度

上面仅仅是把中断当作gpio驱动来写，实际上这种方法是不可取的，因为应用会频繁调用read，导致，cpu居高不下，浪费系统资源。这时候需要实现休眠的功能。

set_current_state(TASK_INTERRUPT)

## 文件IO

1. 非阻塞
2. 阻塞
3. 多路复用——select/poll
4. 异步信号通知——faync



### 文件IO之阻塞模型

linux应用中大部分的函数接口都是阻塞接口，scanf()/read()/write()/accept()/recv()......

阻塞：当进程在读取设备外部资源数据时，资源没有准备好，进程就会休眠。

1. 将当前进程加入到等待队列头中

   ```
   add_wait_queue(wait_queue_head_t * q, wait_queue_t * wait)
   ```

2. 将当前进程状态设置成（可接受中断信号）TASK_INTERRUPTIBLE

   ```c
   set_current_state(TASK_INTERRUPTIBLE)
   ```

   

3. 让出调度--休眠

   ```c
   schedule(void)
   ```

#### 更加智能的接口

`wait_event_interruptible`，等同于上面的三个接口，使用方法：

1. 初始化等待队列头

   ```
   init_waitqueue_head(wait_queue_head_t *q)
   ```

   

2. 在需要等待的时候进行休眠

   ```c
   //内部会构建一个等待队列项节点wait_queue_t
   wait_event_interruptible(wait_queue_head_t wq, int condition)	
   /*
   参数1： 等待队列头
   参数2： 条件，如果是为假，就会等待，如果为真，就不会等待
   可以用一标志位，来表示是否有数据
   */
   ```

3. 在合适的时候（有数据的时候），将进程唤醒

   ```c
   wake_up_interruptible(wait_queue_head_t *q)
   ```

   

### 文件IO之非阻塞模型

在读写的时候，如果没有数据，立刻返回，并且返回一个出错码

用户空间：

`open("/dev/key0", O_RDWR|O_NONBLOCK);`

------

内核空间：

```c
//如果当前是非阻塞模式，并且没有数据，立马返回一个出错码
if(filp->f_flags & O_NONBLOCK && !key_dev->key_state)
    return -EAGAIN;
```

非阻塞型IO用的会比较少，因为比较耗资源，仅仅减少了`copy_to_user`的调用，大多数情况下，还是用阻塞型比较多。

不过，阻塞模型虽然解决了无谓的cpu消耗，当需要同时监控多个fd的时候，会存在以下问题：

1. 需要同时新建多个线程分别监控文件io，产生了额外的资源消耗
2. 处理fd事件的时候可能丢失正在发生的fd事件

引入select/poll/epoll多路复用模型。。。。

### 文件IO之多路复用

select/poll/epoll

如果要在应用中使用select和poll对设备文件进行了监控，驱动就需要实现poll接口。

用户空间：

```
ret = select(maxfd + 1, &readfds, NULL, NULL, &timeout);
或
ret = poll(fds, nfds, 1000*3);
```

------

内核空间：

```c
static unsigned int keyirq_demo_poll(struct file *flip, struct poll_table_struct *pts)
{
    unsigned int mask;

    //调用poll_wait，将当前的等待队列注册到系统中
    poll_wait(flip, &keyirq_demo_dev->wq_head, pts);
    
    if(!keyirq_demo_dev->key_state)
    {
        //无数据时返回0
        mask = 0;
    }
    else
    {
        //有数据时返回POLLIN
        mask |= POLL_IN;
    }

    return mask;
}
struct file_operations fops = {
    .owner      = THIS_MODULE,          //拥有该结构的模块的指针，一般为THIS_MODULES 这个成员用来在它的操作还在被使用时阻止模块被卸载
    .open       = gpio_demo_open,     
    .release    = gpio_demo_release,
    .read       = gpio_demo_read,
    .write      = gpio_demo_write,
    .poll      = gpio_demo_poll,
};
```



## 添加到总线

后续补充